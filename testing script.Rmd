---
title: "tryout_abm"
author: "SKK"
date: "2023-05-10"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
pacman::p_load(tidyverse)

```

# get probabilities
```{r husstande}
setwd("C:/Users/sarak/OneDrive - Aarhus universitet/26102021/Cog sci/4_semester/EXAMS/SoCult/data")
husstande <- read.csv("husstandsstørrelse2012-2022.csv",header=TRUE)
hus <- husstande %>% 
  rowwise() %>% 
  mutate(mean = mean(c(X2012:X2022))) %>% 
  mutate(sd=sd(c(X2012:X2022))) %>% 
  mutate(n=as.factor(X.)) %>% 
  mutate(n=as.numeric(n))

n2022 <- sum(hus$X2022)

hus_prob = c(hus[1, 12] / n2022,#be alone
                                                                                hus[2, 12] / n2022,#household of 2
                                                                                hus[3, 12] / n2022,#3
                                                                                hus[4, 12] / n2022,#4
                                                                                hus[5, 12] / n2022,#5
                                                                                hus[6, 12] / n2022,#6
                                                                                hus[7, 12] / n2022,#7
                                                                                hus[8, 12] / n2022#8
             )


```

```{r venner}
procent <- c(1,
    2,
    5,
    8,
    12,
    20,
    10,
    4,
    6,
    2,
    30)

ven_prob <- procent/100
# sum(procent) #test hvis det giver 100%
#n_numb <- 1430 #antal respondenter
```

```{r introvert/extrovert}
#from Emma and Mias work
ie_prob <-   c(0.05, 0.15, 0.15, 0.1, 0.1, 0.15, 0.15, 0.1, 0.05)

#or just a batteri som 0-10 with mean 5 and sd 2, meaning that having a battery of 1 or 9 is extreme cases and that most people lie with in 1-9 = 95%
library(truncnorm)
hist(rtruncnorm(n=1000, a=0, b=10, mean=5, sd=2))
hist <- hist(rtruncnorm(n=1000, a=0, b=10, mean=5, sd=2))
soba_prob <- hist$density #probability for each increment from 0-10 on batteri scale
```

```{r fritidsinteresser}
setwd("C:/Users/sarak/OneDrive - Aarhus universitet/26102021/Cog sci/4_semester/EXAMS/SoCult/data")
fritid <- read.csv("fritidsinteresser2022.csv",header=TRUE,sep=";")
# 14 forskellige kategorier, der er værd at tage med (to steder er (angivet med +) er underkategorien taget fra, som at simplificere)

fritid <- fritid %>% 
  rowwise() %>% 
  mutate(mean = mean(c(X1:X4))) #create mean over kvartaler

int_prob <- fritid$mean/100 #probability per fritidsinteresse i samme rækkefølge som i dataframet
```

```{r saved probabilties}
setwd('.')
load("prob.RData")
```

```{r saved probabilties written out}
ie_prob <- c(0.05, 0.15, 0.15, 0.10, 0.10, 0.15, 0.15, 0.10, 0.05) #Introvert/extrovert prob on scale from 1 - 10. From Emma and Mie
int_prob <- c(0.955, 0.955, 0.435, 0.645, 0.625, 0.545, 0.390, 0.325, 0.845, 0.750, 0.320, 0.355, 0.250, 0.215) #Interest probabilities. 14 different interests taken from Statistikbanken.
ven_prob <- c(0.01, 0.02, 0.05, 0.08, 0.12, 0.20, 0.10, 0.04, 0.06, 0.02, 0.30) #Probabilities of having different number of friends. Taken from Vive paper
hus_prob <-c(0.3970565,0.333184,0.1130965,0.1074418, 0.03661024,0.008320509, 0.002352696, 0.001937746) # Number of people in your household probability
```

# Prepare ABM environment
## global variables
```{r global}
iterations <- 1   #How many times do we want to run the model? Starting off with making it run once
n_people <- 64    #How many people are at a party?
n_tables <- 8     #for round & square
n_seats <- 8      # tables
indslag <- NA     #no added external stimuli yet
boundent_move <- NA #no added restricted move time yet
df_collected <- tibble(expand.grid(iteration=seq(iterations), # Create an empty list to store the data frames
                                   table_type=NA,
                                   party=vector("list", length = iterations),
                                   pre_network=vector("list", length = iterations),
                                   post_network=vector("list", length = iterations)
                                   )
                       )
tics <- 20 #each tic is 30 minutes

```

## Set the tables
### Make contact networks
structure is table (1:8), seat (1:8), indices for contact seats (1:8) with 1:5 contact seats, and their seat number depending on which table they are seated at (fx. table 1 seat 1 = new_Seat 11).

They are saved in this workspace
```{r}
setwd('.')
load("tables.RData") #not completely updated

#column 3 in all dataframes have to be ID
```

```{r round}
#input the seatno with the current seatno can make contact with in the contactseatno
#round
round_tables <- tibble(expand.grid(table = seq(n_tables), seat = seq(n_seats), ID = 0, indices=NA))
#add table no to their seat no
round_tables$new_seat <-paste(round_tables$table, round_tables$seat, sep='') 


# make contact seats
for (i in 1:nrow(round_tables)) {
   seat <- round_tables$seat[i]
   
   # Calculate the indices for the contact seats
   if (seat == 1 ){
     indices <- c(2,8)}
   else if (seat == 2){
     indices <- c(1,3)}
   else if (seat == 3){
     indices <- c(2,4)}
   else if (seat == 4){
     indices <- c(3,5)}
   else if (seat == 5){
     indices <- c(4,6)} 
   else if (seat == 6){
     indices <- c(5,7)}  
   else if (seat == 7){
     indices <- c(6,8)}  
   else if (seat == 8){
     indices <- c(7,1)} 
  #add to index
  index <- c()
  for (n in 1:length(indices)){
    idx <- paste(round_tables$table[i], indices[n],sep='')
    index <- c(index,idx)
  }
  round_tables$indices[i] <- paste(index, collapse = ', ')

}

round <- expand.grid(from=round_tables$new_seat,to=round_tables$new_seat)
round$weight <- 0
round <- filter(round, from != to)
#Add weight to all the friendships we just created
for (i in 1:nrow(round_tables)){
  current_id <- round_tables$new_seat[i]
  temp <- round %>% filter(from==current_id)
   for (k in strsplit(round_tables$indices[i], ", ")[[1]]){
     temp2 <- temp %>% filter(to==k)
      temp2$weight <- temp2$weight + 1
       temp <- temp %>% filter(to!=k)
      temp <- rbind(temp2, temp)
  }
    round <- round %>% filter(from!=current_id)
    round <- rbind(round, temp)
}

# for visualisation
round <- round[!(round$weight==0),]
round_graph <-
  graph_from_data_frame(d = round,
                        vertices = round_tables$new_seat,
                        directed = TRUE)

plot(round_graph,
     layout = layout_nicely, # Explore layouts!
     edge.arrow.size = 0.2) 

```

```{r square}
#square
square_tables <- tibble(expand.grid(table = seq(n_tables), seat = seq(n_seats), ID = 0, indices =NA))
square_tables$new_seat <- paste(square_tables$table, square_tables$seat, sep='') 


# make contact seats
for (i in 1:nrow(square_tables)) {
   seat <- square_tables$seat[i]
   
   # Calculate the indices for the contact seats
   if (seat == 1 ){
     indices <- c(2,3,4,7,8)}
   else if (seat == 2){
     indices <- c(1,3,4,7,8)}
   else if (seat == 3){
     indices <- c(1,2,4,5,6)}
   else if (seat == 4){
     indices <- c(1,2,3,5,6)}
   else if (seat == 5){
     indices <- c(3,4,6,7,8)} 
   else if (seat == 6){
     indices <- c(3,4,5,7,8)}  
   else if (seat == 7){
     indices <- c(5,6,8,1,2)}  
   else if (seat == 8){
     indices <- c(5,6,7,1,2)} 
  #add to index
  index <- c()
  for (n in 1:length(indices)){
    idx <- paste(square_tables$table[i], indices[n],sep='')
    index <- c(index,idx)
  }
  square_tables$indices[i] <- paste(index, collapse = ', ')

}

square <- expand.grid(from=square_tables$new_seat,to=square_tables$new_seat)
square$weight <- 0
square <- filter(square, from != to)
#Add weight to all the friendships we just created
for (i in 1:nrow(square_tables)){
  current_id <- square_tables$new_seat[i]
  temp <- square %>% filter(from==current_id)
   for (k in strsplit(square_tables$indices[i], ", ")[[1]]){
     temp2 <- temp %>% filter(to==k)
      temp2$weight <- temp2$weight + 1
       temp <- temp %>% filter(to!=k)
      temp <- rbind(temp2, temp)
  }
    square <- square %>% filter(from!=current_id)
    square <- rbind(square, temp)
}

# for visualisation
square <- square[!(square$weight==0),]
square_graph <-
  graph_from_data_frame(d = square,
                        vertices = square_tables$new_seat,
                        directed = TRUE)

plot(square_graph,
     layout = layout_nicely, # Explore layouts!
     edge.arrow.size = 0.2) 
```

```{r long}
n_people <- 64
#long
long_table <- tibble(table=1,seat=1:n_people,ID=0,indices=NA)
# Iterate over each row in the dataframe
for (i in 1:nrow(long_table)) {
   seat <- i
     # Calculate the indices for the contact seats
   #corners
   if (seat == 1 ){
     indices <- c(seat +1, seat + 2, seat + 3)}
   else if (seat == 2 ){
     indices <- c(seat -1, seat +1, seat + 2)}
   else if (seat == n_people-1){
     indices <- c(seat +1, seat - 2, seat -1)}
   else if (seat == n_people){
     indicies <- c(seat-1, seat-2, seat-3)
   }
   #index +3 and -3, for some reason is off...
   else if (seat == 3){
     indices <- c(seat-1,seat-2,seat+1,seat+2,seat+3)
   }
   else if (seat == n_people-2){
     indices <- c(seat-1,seat-2,seat+1,seat+2,seat-3)
   }
   #the rest
   else if (seat %% 2){
     indices <- c(seat - 3, seat - 2, seat - 1, seat + 1, seat + 2)
   } else {
     indices <- c(seat - 1, seat - 2, seat + 1, seat + 2, seat + 3)
   }
  # Remove any indices that are out of bounds
  indices <- indices[indices > 0 & indices < n_people+1]
  #add to index
  n_indices <- length(indices)
  index <- c()
  for (n in 1:n_indices){
    index <- c(index,indices[n])
  }
  long_table$indices[i] <- paste(index, collapse = ', ')

}

long <- expand.grid(from=long_table$seat,to=long_table$seat)
long$weight <- 0
long <- filter(long, from != to)
#Add weight to all the friendships we just created
for (i in 1:nrow(long_table)){
  current_id <- long_table$seat[i]
  temp <- long %>% filter(from==current_id)
   for (k in strsplit(long_table$indices[i], ", ")[[1]]){
     temp2 <- temp %>% filter(to==k)
      temp2$weight <- temp2$weight + 1
       temp <- temp %>% filter(to!=k)
      temp <- rbind(temp2, temp)
  }
    long <- long %>% filter(from!=current_id)
    long <- rbind(long, temp)
}

#Plotting Friendship network
pacman::p_load(tidyverse,
               here,
               network,
               igraph,
               ggraph,
               tidygraph,
               patchwork,
               bootnet)
# for visualisation
long <- long[!(long$weight==0),]
long_graph <-
  graph_from_data_frame(d = long,
                        vertices = long_table$seat,
                        directed = TRUE)

plot(long_graph,
     layout = layout_nicely, # Explore layouts!
     edge.arrow.size = 0.2) 
```

## Make hosts
for each iterations

```{r make hosts}
### Define hosts of parties ###

# All host shares at least 1 interest with everyone, and are connected to all guests
make_hosts <- function(number_of_iterations){ 
  max_hosts <- iterations+100 #define the highest host id (+100 to make hosts identifiable)
    
  hosts <<- tibble(
      ID = 101:max_hosts, #+100 to give the hosts identifyable ID's
      ie = sample(1:9, iterations, replace = TRUE, prob =  ie_prob),    #introvert / extrovert scale from 1-9, from Emma and Mie
      n_household = sample(1:8,iterations, replace =TRUE, prob = hus_prob), #Number of people in your household
      n_closefriends = n_people-1, #friends with every one at the party
      #in the tryout markdown the randomization of interest was tested an only a few combination was shown twice, therefore we will not do anything further to randomize the selected interests.
      interest1 = sample(1:14, iterations, replace = TRUE, prob = int_prob),
      interest2 = sample(1:14, iterations, replace = TRUE, prob = int_prob),
      interest3 = sample(1:14, iterations, replace = TRUE, prob = int_prob),
      weight_time = round((runif(iterations, min = -1, max = 1)),digits = 2),#testing to make weights for the satisfaction rate
      weight_interest = 1-abs(weight_time)#testing to make weight for the satisfaction rate
    )
}
``` 
  
## Make party
```{r setup people for party}
### Choosing who the guests are at all parties
make_party <- function(index_of_current_iteration){
  i <- index_of_current_iteration
  
  ###selecting a host####
  host <- hosts[i,]
  host_interest <- c(host$interest1,host$interest2,host$interest3)
  
  ###making guests###
  
  #Assigning variables to guests 
  guests <- tibble(ID = 2:n_people-1, #Creating 63 people
                    ie = sample(1:9, n_people-1, replace = TRUE, prob =  ie_prob), #Introvert/extrovert values to people
  
                    n_household = sample(1:8, n_people-1, replace =TRUE, prob = hus_prob), #Amount of people in household
                    n_closefriends = sample(1:10, n_people-1, replace = TRUE, prob = ven_prob[1:10]), #Amount of close friends (everyone has at least one friend (the host))
                   
                    interest1 = sample(host_interest,n_people-1,replace=TRUE), #choose a random interest that fits with the host
                    interest2 = sample(1:14, n_people-1, replace = TRUE, prob = int_prob),
                    interest3 = sample(1:14, n_people-1, replace = TRUE, prob = int_prob),
                   
                    weight_time = round((runif(n_people-1, min = -1, max = 1)),digits = 2),#testing to make weights for the satisfaction rate
                    weight_interest = 1-abs(weight_time)#testing to make weight for the satisfaction rate
  )
  ### make the party ###
  party <- rbind(host,guests)
  party <<- party %>% 
    mutate(friend_id=NA) %>% 
    mutate(satisfaction_baseline = 0) %>% # not simulated yet
    mutate(satisfaction = 0) %>% 
    mutate(moves = 0)#how their satisfaction if moved according

}
```

## Prenetwork
```{r friends network}
make_prenetwork <- function(party_dataframe){
  party <- party_dataframe

  ### Creating a network of the connections pre-party###
  pre_network <- expand.grid(from=party$ID,to=party$ID)
  pre_network$weight <- 0
  pre_network <- filter(pre_network, from != to)
  
  ### Assigning friends to everyone
  for (i in 1:nrow(party)) {
    num_friends <- party$n_closefriends[i]  # Get the number of friends for the current person
    id_pool <- party$ID[-i]  # Exclude the current person's ID from the pool of potential friends
    
    ids_above_100 <- id_pool[id_pool > 100] #Separate people into host and guests
    ids_below_100 <- id_pool[id_pool <= 100]
    
    # If the current person needs to have more than 1 friend (more than just the host)
    if (num_friends >= 1) {
      # Add all IDs above 100 as friends
      friend_ids_above_100 <- ids_above_100
      remaining_friends <- num_friends - 1
      
      # Randomly select additional friend IDs from below 100
      friend_ids_below_100 <- sample(ids_below_100, size = remaining_friends, replace = FALSE)
      
      # Combine the friend IDs
      friend_ids <- c(friend_ids_above_100, friend_ids_below_100)
    } else {
      # Randomly select friend IDs from above 100
      friend_ids <- sample(ids_above_100, size = num_friends, replace = FALSE)
    }

    # Assign the selected friend IDs to the corresponding row in the dataframe
    party$friend_id[i] <- paste(friend_ids, collapse = ', ')
    party <<- party #save to environmet
  }
  
  #Add weight to all the friendships we just created
  for (i in 1:nrow(party)){
    current_id <- party$ID[i]
    temp <- pre_network %>% filter(from==current_id)
     for (k in strsplit(party$friend_id[i], ", ")[[1]]){
       temp2 <- temp %>% filter(to==k)
        temp2$weight <- temp2$weight + 16
         temp <- temp %>% filter(to!=k)
        temp <- rbind(temp2, temp)
    }
      pre_network <- pre_network %>% filter(from!=current_id)
      pre_network <- rbind(pre_network, temp)
  }
 pre_network <<- pre_network
}
make_prenetwork(party)
```

## Seat guests
```{r creating tables}
#SK
#Create a list of people that are not seated yet

no_seat <- party$ID
no_seat <- no_seat[sample(length(no_seat))]

# assign people new seats
table$ID[table$ID==0] <<- sample(no_seat, size = nrow(no_seat), replace = FALSE)


#assuming person index = person, no_seat list exists
if (decision_move == 'yes'){
  #remove from their seat
  table$ID[person] <- 0 #column 3 in all dataframes have to be ID
  #add to no seat
  new_no_seat <- c(person)
  no_seat <- append(no_seat,new_no_seat)
} #else stay seated
```

## Evaluteting satisfaction
### not made yet
```{r}
#function not made 
```

```{r}
#add another function for calculating satisfaction
```

# Running ABM
##not done
```{r}
make_prenetwork(party)
#do this three times for each type of table/party
table_type <- vector("list", length = 3)
table_type[[1]] <- long_table
table_type[[2]] <- round_tables
table_type[[3]] <- square_tables

#remember to load probabilities, table types and global variables beforehand 
start <- format(Sys.time(),"%HH %MM %SS")
for (p in table_type){
  #make hosts
  hosts <- make_hosts(iterations)
  
  #get the table type
  if (table == table_type[[1]]){
  #save table type for future reference
    df_collected$table_type[i] <- long
    #get the table
    table <- long_table
  }else if (table == table_type[[2]]){
    #save table type for future reference
    df_collected$table_type[i] <- round
    #get the table
    table <- round_tables
  }else if (table == table_type[[3]]){
    #save table type for future reference
    df_collected$table_type[i] <- square
    #get the table
    table <- square_tables
  }

  
  #repeat x times for each type of table/party
  for (i in 1:iterations){
    #save iteration for future reference
    df_collected$iteration[i] <- i
    
    #make party
    party <- make_party(i)
    #save party
    df_collected$party[[i]] <- party

    
    #make prenetwork
    network <- make_prenetwork(party)
    #save prenetwork
    df_collected$pre_network[[i]] <- network

    
    #seat everybody to start off
    #get people
    no_seat <- party$ID
    #shuffle
    no_seat <- no_seat[sample(length(no_seat))]
    # assign people seats
    table$ID[table$ID==0] <<- sample(no_seat, size = nrow(no_seat), replace = FALSE)
    no_seat <- c()

    #start party
    for (tic in 1:tics){
      for (person in 1:nrow(party)){#do this for each person
        
        ## working her###
        
      #look at contact seats
        #get ID's for people sitting in contact seats
        #get contact seats
        con_indices <- as.numeric(strsplit(table$indices[person], ",\\s*")[[1]])
        #get the ID for the contact seats
        con_people <- c()
        for (ci in 1:length(con_indices)){
          con_person <- table[ci,3][[1]] #column 3 in all dataframes have to be ID
          # Combine the friend IDs
          con_people <- c(con_people, con_person)
          #save in right format
          con_people <- paste(con_people, collapse = ', ')
          con_people <- as.numeric(strsplit(con_people, ",\\s*")[[1]])
        }
        
        #make a dataframe with surrounding peoples variables
        relation_possibilities <- tibble(seat=con_indices,id=con_people, outcome=0, n_interest = 0, friendshipscore = 0, decision = 0)
        #fill
        row1 <- which(party$ID == person)

        for (cp in length(con_people)){
              #in n_interest
          row2 <- which(party$ID==con_people[2])

          # Get the values in the columns for the specified rows
          values_row1 <- party[row1, c("interest1", "interest2", "interest3")]
          values_row2 <- party[row2, c("interest1", "interest2", "interest3")]
          
          # Check if the values are identical for the two rows
          relation_possibilities$n_interest[cp] <- sum(sapply(values_row1, function(x) any(values_row2 %in% x)))
          
             #friendshipscore
          row_index <- which(network$from == person & network$to == cp)
          relation_possibilities$frienshipscore[cp] <- network$weight[row_index]
          
            # outcome column
          wf <- party$weight_time[person]
          wa <- party$weight_interest[person]
          relation_possibilities$outcome[cp] <- wf *
            relation_possibilities$frienshipscore[cp] + wa *
            relation_possibilities$n_interest[cp] #watch out since old friend weigh heavily in this equation, hopefully it will surfice
          
        }
        
        #determine commitment
        relation_possibilities$commitment[cp] <- relation_possibilities$outcome[cp] + (iterations - i +1) - max(relation_possibilities$outcome) 
        #make decision whether to become friends
        # Define a threshold value
        threshold <- 0.5 #arbitrary
        # Convert values to yes(1) or no(0) answer
        relation_possibilities$decision[cp] <- ifelse(relation_possibilities$commitment[cp] >= threshold, 1, 0)
        #evaluate friendshipstatus
        #add 1 weight from the parson wanting the relationsship
        for (cp in length(con_people)){
        row_index <- which(network$from == person & network$to == cp)
        network$weight[[row_index]] <- network$weight[[row_index]] + relation_possibilities$decision[cp]
        }


      #calculate proximity
        #check whether peoples current friends are near (meaning whether they are within contact seats)
        #get who we are looking at
        prox <- pre_network %>% 
          filter(weight!=0) %>% 
          filter(from == person)
        prox_friends <- c() #empty vector to store friend ID's
        for (ap in 1:nrow(prox)){
          friend <- prox$to[ap]
          prox_friends <- append(prox_friends,friend)
        }

        check_friends_nearby <- sum(sapply(con_people, function(x) any(prox_friends %in% x))) #number of true instances of there contact_people overlap with current friend network
        
      #evalute overall satisfaction
          party[person, "satisfaction"][[1]] <- party[person, "satisfaction"][[1]] + check_friends_nearby #guests satisfaction is updated with the percentage of the people that they can sit next to actually are their friends (have a weight above 0) currently

        ### working session buttom ####
    
      #decide whether to move
        # Define a threshold value
        threshold <- 1 - party$ie[person]/10 #percent needed for people to make a decision e.g. ie = 9 (extrovert) /10 = 0,9 1-0,9 = 0,1 = 10% change needed for them to stay
          #change
          change <- (party$satisfaction_baseline[person] - party$satisfaction[person]) / party$satisfaction_baseline[person]
        # Convert values to yes(1) or no(0) answer
        party[person, "moves"][[1]] <- ifelse() relation_possibilities$decision[cp] <- ifelse(relation_possibilities$commitment[cp] >= threshold, 1, 0)

      #assuming person index = person, no_seat list exists
        if (decision_move == 'yes'){
          #remove from their seat
          table$ID[person] <- 0
          #add to no seat
          new_no_seat <- c(person)
          no_seat <- append(no_seat,new_no_seat)
          #add one value to their move count
          party$moves[person] <- party$moves[person] +1
        } #else stay seated
      }#go from individual to global level
      
      #seat everyone
      table$ID[table$ID==0] <<- sample(no_seat, size = nrow(no_seat), replace = FALSE)
      #clear out no_seat_list
      no_seat <- c()
      
      #reset their satisfaction status back to baseline

      
    } #after all tics
    
    #save postnetwork
    df_collected$post_network[[i]] <- post_network

  }
}
end <- format(Sys.time(),"%HH %MM %SS")

#duration of running abm
duration <- end-start
paste("The ABM on",table_type,"with",iterations, "iterations took",duration)

```

## last of ABM
```{r}
# Perform iterations and generate data frames
for (i in 1:n_iterations) {
  # Perform some operations to generate a data frame
  df <- ...
  
  # Add the data frame to the list
  df_collected$pre_network[[i]] <- pre_network
  df_collected$post_network[[i]] <- post_network
  df_collected$party[[i]] <- party
  df_collected$iteration[i] <- iteration_kommet_til
  df_collected$table_type[i] <- table_type
}

# Save the combined data frame
write.csv(df_collected, file = "combined_df.csv")

```


# Investigate ABM
```{r test hosts}
#check it out
# head(hosts)
#seems good

#could be fun to make a radar chart of the hosts
#https://www.datanovia.com/en/blog/beautiful-radar-chart-in-r-using-fmsb-and-ggplot-packages/
#opar <- par() 
# Define settings for plotting in a 3x4 grid, with appropriate margins:
#par(mar = rep(0.8,3))
#par(mfrow = c(3,3))
# Produce a radar-chart for each student
#for (i in 1:nrow(hosts)) {
 # radarchart(
  #  hosts[c(2:7, i), ],#hosts[ i,c(2:7)]
   # pfcol = c("#99999980",NA),
    #pcol= c(NA,2), plty = 1, plwd = 2,
#    title = row.names(hosts)[i]
 # )
#}
# Restore the standard par() settings
#par <- par(opar) 
```

```{r test interest overlap}
# par(mfrow=c(1,3))
# plot(density(hosts$interest1))
# plot(density(hosts$interest2))
# plot(density(hosts$interest3))
# #library(plyr)
# dplyr::count_(hosts, vars = c('interest1','interest2','interest3'))
# aggregate(ID ~ ., hosts, FUN = length)
# 
# dupes <- apply(hosts[,2:4], 1, function(x) any(duplicated(x)))
# dupes <- hosts[dupes, ]
# dup <- dupes[1,]
# stringr::str_count(dupes) #18 true #four characters, =28 procent had an overlap in at least two coloumns
```

```{r test interest overlap}
# #test if people have overlap in interests within themselves
# dupes <- apply(guests[,5:7], 1, function(x) any(duplicated(x)))
# stringr::str_count(dupes) #16 true #four characters, =25 procent had an overlap in at least two coloumns

```

```{r plot prenetwork}
pacman::p_load(tidyverse,
               here,
               network,
               igraph,
               ggraph,
               tidygraph,
               patchwork)
nodes <- party$ID

pre_igraph <-
  graph_from_data_frame(d = pre_network,
                        vertices = nodes,
                        directed = TRUE)


pre_igraph <- simplify(pre_igraph, 
                                  remove.multiple = TRUE, 
                                  remove.loops = TRUE,
                                  edge.attr.comb = igraph_opt("edge.attr.comb"))



E(pre_igraph)$arrow.mode <- 0



V(pre_igraph)$label <- "" 

V(pre_igraph)$frame.color <- "white"
V(pre_igraph)$color <- "orange"
E(pre_igraph)$width <- edge_attr(pre_igraph)$weight/16 #this one adjusts the size of arrows 
#E(pre_igraph)$arrow.size <- 0.01
plot(pre_igraph,
     layout=layout_nicely,
     #vertex.label= V(pr,
     edge.arrow.size=0.01#,
     #vertex.label.color = "black",
     #vertex.size=node.size
     )

#ask Emma how to make their cool network plot
```


# mess --- måske er der noget godt der nede...

```{r friends network}
guests$friends <- map(guests$missing_friends, function(x) sample(guests$ID, x, replace = FALSE), )

pre_network %>% filter(from==105)

#step 2: connect everybody with everybody using their number of friends
#make lists of possible connections
for (id in seq(guests$ID)){
  
  
  #friends time
  n_rows_friends = guests$n_closefriends[[id]]
  row = guests$ID[[id]]
  if (n_rows_friends == 0){next}
  df_temp_fri <-  tibble(expand.grid(ID=row,
                     p_friends = seq(n_rows_friends)
                     ))
  #save dataframe
  if (id == 1){
    df_fri <- df_temp_fri
  } else {
    df_fri <- rbind(df_fri,df_temp_fri)
  }
}

list_of_friends <- df_fri[,1] %>% 
  mutate(row=row.names(df_fri))



pre_network <-  tibble(from =NULL, to=NULL, weight=NULL)

list_of_friends_guest <- list_of_friends[66:553,]
#this loop makes the right number of connections, but NA occures for to coloumn after first run..., every second person is "satisfied" with friends in party dataframe...
for (person in list_of_friends_guest[["ID"]]){ #need for be done as many times as there are people on the list
  if (party$missing_friends[person] > 0){
    choosen = list_of_friends_guest[sample(1:nrow(list_of_friends_guest), 1), ]
    choosen_friend = choosen[["ID"]]
    connection = tibble(from   = guests[person,1],
                         to = guests[choosen_friend,1],
                         weight = 16)
    pre_network <- rbind(pre_network, connection)
    
    #remove from list
    #choosen
    row =as.numeric(choosen[["n"]])
    list_of_friends_guest <- list_of_friends_guest[-row,]
    #person
    temp_rows=as.numeric(list_of_friends_guest$row[list_of_friends_guest$ID==person])
    row = sample(temp_rows, 1)
    list_of_friends_guest <- list_of_friends_guest[-row,]
    
    party$missing_friends[party$ID == person] <- party$missing_friends[party$ID == person] -1
    # party$missing_friends[party$ID == choosen_friend] <- party$missing_friends[party$ID == choosen_friend] -1

    
  }else if (party$missing_friends[person] == 0){next}
}


#this loop makes the right number of connections, but NA occures for to coloumn after first run..., every second person is "satisfied" with friends in party dataframe...
for (person in list_of_friends_guest[["ID"]]){ #need for be done as many times as there are people on the list
  if (party$missing_friends[person] > 0){
    choosen = list_of_friends_guest[sample(1:nrow(list_of_friends_guest), 1), ]
    repeat{
      
      
    }
    choosen_friend = choosen[["ID"]]
    connection = tibble(from   = guests[person,1],
                         to = guests[choosen_friend,1],
                         weight = 16)
    pre_network <- rbind(pre_network, connection)
    
    #remove from list
    row =as.numeric(choosen[["n"]])
    list_of_friends_guest <- list_of_friends_guest[-row,]
    
    party$missing_friends[party$ID == person] <- party$missing_friends[party$ID == person] -1

    
  }else if (party$missing_friends[person] == 0){next}
}

#this loop works but for all rows in the possible list of friends...
for (person in list_of_friends_guest[["ID"]]){ #need for be done as many times as there are people on the list
  if (party$missing_friends[person] > 0){
    choosen = list_of_friends_guest[sample(1:nrow(list_of_friends_guest), 1), ]
    choosen_friend = choosen[["ID"]]
    connection = tibble(from   = guests[person,1],
                         to = guests[choosen_friend,1],
                         weight = 16)
    pre_network <- rbind(pre_network, connection)
    
    #remove from list
    #row =as.numeric(choosen[["n"]])
    #list_of_friends_guest <- list_of_friends_guest[-row,]
    
    #party$missing_friends[party$ID == person] <- -1  
    
  }else if (party$missing_friends[person] > 0){next}
}


#this loop works but once for each person in unique(list_of_friends_guest)
for (person in unique(list_of_friends_guest[["ID"]])){ #need for be done as many times as there are people on the list
  if (party$missing_friends[person] > 0){
    choosen = list_of_friends_guest[sample(1:nrow(list_of_friends_guest), 1), ]
    choosen_friend = choosen[["ID"]]
    connection = tibble(from   = guests[person,1],
                         to = guests[choosen_friend,1],
                         weight = 16)
    pre_network <- rbind(pre_network, connection)
    
    #remove from list
    #row =as.numeric(choosen[["n"]])
    #list_of_friends_guest <- list_of_friends_guest[-row,]
    
    #party$missing_friends[party$ID == person] <- -1  
    
  }else if (party$missing_friends[person] > 0){next}
}

#loop that worked yesterday but only made one connection per guest
for (person in unique(list_of_friends[["ID"]])){ #need for be done as many times as there are people on the list
  if (guests$missing_friends[person] > 0){
    if (nrow(list_friends) > 0){}
    choosen = list_of_friends[sample(1:nrow(list_of_friends), 1), ]
    choosen_friend = choosen[["ID"]]
    connection <- tibble(to = guests[choosen_friend,1],
                         from   = guests[person,1],
                         weight = 16)
    pre_network <- rbind(pre_network, connection)
    
    #remove from list
    row =as.numeric(choosen[["n"]])
    list_of_friends <- list_of_friends[-row,]
    
    guests$missing_friends[guests$ID == person] <- -1  
    
  }
}

#test if it worked
n_connections_needed <-   guests$n_closefriends
pre_network <- pre_network %>% 
  mutate(to=as.numeric(to))
n_connections_have <- xtabs(~pre_network$to)
n_connections <- tibble(nedded =n_connections_needed,
                        have =n_connections_have)
duplicated(n_connections) #all false....
```

```{r network}

#empty networks
friends <- tibble(to=NA,from=NA,weight=NA)

families <- tibble(to=NA,from=NA,weight=NA)


#make lists of possible connections
for (id in seq(party$ID)){
  
  #family
  if (party$n_household[[id]] == 1){ #people who have no family
    break
  } else {
  n_rows_family = party$n_household[[id]]
  df_temp_fam <-  tibble(expand.grid(ID=unique(id),
                     p_familiy = seq(n_rows_family)
                     ))
  }
  #save dataframe
  if (id == 1){
    df_fam <- df_temp_fam
  } else {
    df_fam <- rbind(df_fam,df_temp_fam)
  }
  
  #friends time
  n_rows_friends = party$n_closefriends[[id]] 
  df_temp_fri <-  tibble(expand.grid(ID=unique(id),
                     p_friends = seq(n_rows_friends)
                     ))
  #save dataframe
  if (id == 1){
    df_fri <- df_temp_fri
  } else {
    df_fri <- rbind(df_fri,df_temp_fri)
  }
}

list_of_friends <- df_fri[,1]
list_of_family <- df_fam[,1]

#reorder
  fam_dec <- party[order(-party$n_household),]
  #remove people who live alone
  fam_dec <- fam_dec[!(fam_dec$n_household == 1),]
  
#make families
for (people in nrow(fam_dec)){
  #setup count handler
  n_people <- 1
  max = fam_dec$n_household[[n_people]] 
  n_relatives <- 2
  person <- n_people+1

  repeat{
  while (n_relatives <= max){
    n_relatives <- 1+n_relatives
    #row             #to                #from             #weight
                   #the person at hand
    connection <- tibble(to=fam_dec[n_people,1], from=fam_dec[person,1],weight= 33 )
    
    #add to dataframe
    families <- rbind(families, connection)
    
    #add to counters
    n_relatives= +1
    person = +1
    if (n_relatives> max){next}
  } 
  n_people = +1 #move to next person
  max = fam_dec$n_household[[n_people]] #set new max
  #see if it already has been filled
  test <- xtabs(~from,families)
  n_relatives <- test[[n_people]][1]
  if (n_people > nrow(fam_dec)){break}
} 
}

  
  
  
  

  
#chatgpt
library(igraph)

# create an empty graph
edges <- NULL
g <- graph(edges = edges)

# add vertices to the graph
vertex_names <- unique(party$ID)
V(g)$name <- vertex_names

# add edges to the graph based on n_friends and n_family
for (i in 1:nrow(party)) {
  # get the source and target nodes
  source_node <- party[i, "ID"]
  target_node <- sample(vertex_names, party[i, "n_closefriends"] + party[i, "n_household"], replace = FALSE)
  
  # check if the target node is not the source node and if there is no existing edge
  for (j in target_node) {
    if (j != source_node && !edge.between(g, source_node, j)) {
      # determine the weight based on whether it's a friend or family
      if (j %in% sample(party[party$ID == source_node, "n_closefriends"], party[i, "n_closefriends"], replace = FALSE)) {
        weight <- 16
      } else {
        weight <- 33
      }
      # add the edge to the graph
      g <- add_edge(g, source_node, j, weight = weight)
    }
  }
}













#make friends clusters from interest... nooo
# normalize the n_family and n_friends values
df_norm <- as.data.frame(scale(party[, c("n_family", "n_friends")]))

# perform k-means clustering
set.seed(123) # for reproducibility
k <-  # number of clusters
kmeans_model <- kmeans(df_norm, centers = k)

# add cluster information to original dataframe
df$cluster <- as.factor(kmeans_model$cluster)




pre_party_network <-  tibble(expand.grid(ID=seq(unique(party$ID)),
                                         p_closefriends = seq(party$n_closefriends),
                                         p_familiy = seq(party$n_household)
                                         )
                              ) #%>% 
         # mutate(ID=ifelse(diagnosis=='td',ID+n*2,ID))
# group by ID and calculate the number of rows for each ID
aggregate(ID ~ n_closefriends, data = party, FUN = length)
aggregate(ID ~ n_household, data = party, FUN = length)

for (id in seq(party$ID)){
  
  n_rows_family = party$n_household[[id]]
  n_rows_friends= party$n_closefriends[[id]] 
  
  df_temp_fam <-  tibble(expand.grid(ID=unique(id),
                     p_familiy = seq(n_rows_family)
                     ))
  df_temp_fri <-  tibble(expand.grid(ID=unique(id),
                     p_friends = seq(n_rows_friends)
                     ))
  #save dataframe
  if (id == 1){
    df_fam <- df_temp_fam
    df_fri <- df_temp_fri
  } else {
    df_fam <- rbind(df_fam,df_temp_fam)
    df_fri <- rbind(df_fri,df_temp_fri)
  }
}#as long as it is just a foor loop no return needed
#dataframe structure: to from weight. weight: one weight added everytime they meet a total of 16 weights can be added, family nodes are made to start at 33 (at the end of party ranching from 33-49), friends nodes start at 16 (at the end of party ranching from 16-32)... arbitrary choice at the moment,

```

```{r people}
#to point out the hosts, so we can have interesser/relationer der overlapper med værten
iterations <- 8

n_hosts <- iterations+100 #have the number of hosts needed for running all interations *100 to make them identifiable as hosts
  
  hosts <- tibble(
    ID = 101:n_hosts, #*100 to give the hosts identifyable ID's
    #introvert / extrovert scale from 1-9, from Emma and Mie
     ie = sample(1:9, iterations, replace = TRUE, prob =  c(0.05, 0.15, 0.15, 0.1, 0.1, 0.15, 0.15, 0.1, 0.05)),
    # 
    # #the number does not really matter unless you want to make the network complecated...
     n_household = sample(1:8,iterations, replace =TRUE, prob = hus_prob), 
     n_closefriends = sample(0:10, iterations, replace = TRUE, prob = ven_prob), 
    # 
    #  #in the tryout markdown the randomization of interest was tested an only a few combination was shown twice, therefore we will not do anything further to randomize the selected interests.
     interest1 = sample(1:14, iterations, replace = TRUE, prob = int_prob),
     interest2 = sample(1:14, iterations, replace = TRUE, prob = int_prob),
     interest3 = sample(1:14, iterations, replace = TRUE, prob = int_prob)
  )

 host <- hosts[6,] #choose a host

  #decide host interest
   host_interest <- c(host$interest1,host$interest2,host$interest3)

   #make people
   people <- tibble(
     #individual
     ID = 1:n_people, 
     ie = sample(1:9, n_people, replace = TRUE, prob =  c(0.05, 0.15, 0.15, 0.1, 0.1, 0.15, 0.15, 0.1, 0.05)),
     n_household = sample(1:8, n_people, replace =TRUE, prob = hus_prob),
     n_closefriends = sample(0:10, n_people, replace = TRUE, prob = ven_prob),
     
     #interests based on the selected host
     interest1 = sample(host_interest,n_people,replace=TRUE), #choose a random interest that fits with the host
     interest2 = sample(1:14, n_people, replace = TRUE, prob = int_prob),
     interest3 = sample(1:14, n_people, replace = TRUE, prob = int_prob)
     )


party <- rbind(host,people) 
```
