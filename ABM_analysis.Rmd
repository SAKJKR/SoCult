---
title: "ABM_analysis"
author: "SKK"
date: "2023-05-25"
output: html_document
---

# Investigate ABM

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

pacman::p_load(tidyverse,
               here,
               network,
               igraph,
               ggraph,
               tidygraph,
               patchwork)
```

## Table of content


```{r Load data}
stat <- tibble(expand.grid(iteration = seq(1,100),
                           table = seq(1,3),
                           network = seq(1,2)))
stat <- stat %>% 
  mutate(
                           pre_post = rep(vector("list", length = 600)),
                           degree = NA,
                           degree_mean = NA,
                           degree_dist = NA,
                           transitivity = NA,
                           between = NA,
                           eigen_cen = NA,
                           pre=rep(vector("list", length = 600)),
                           trans_mean = NA,
                           between_mean = NA,
                           eigen_cen_mean = NA
                           )
              
#rename 1:3 to long,round, square
for (row in 1:nrow(stat)){
stat$table[row] <- if (stat$table[row] == 1) "long" else if (stat$table[row] == 2) "round" else "square"
}

for (row in 1:nrow(stat)){
stat$network[row] <- if (stat$network[row] == 1) "pre" else "post" 
}

stat <- arrange(stat, iteration, table)

for (row in 1:nrow(df_collected)){
  #make network graphs
  temp <- df_collected[[3]][[row]]
  edges <- temp$ID
  nodes_pre <- df_collected[[4]][[row]] %>% filter(weight!=0)
  nodes_post <- df_collected[[5]][[row]] %>% filter(weight!=0)
  pre_igraph <- graph_from_data_frame(d = nodes_pre,
                        vertices = edges,
                        directed = TRUE)
  post_igraph <-
  graph_from_data_frame(d = nodes_post,
                        vertices = edges,
                        directed = TRUE)
  #save
  pre_index <- which(stat$iteration == df_collected$iteration[row] & stat$table == df_collected$table_type[row])[1]
  post_index <- which(stat$iteration == df_collected$iteration[row] & stat$table == df_collected$table_type[row])[2]
  #network graphs
  stat$pre_post[[pre_index]] <- pre_igraph#as_long_data_frame(pre_igraph, mode="all"))
  stat$pre_post[[post_index]] <- post_igraph#as_long_data_frame(degree(post_igraph, mode="all"))
  stat$pre[[post_index]] <- pre_igraph
  #make degree
  stat$degree[[pre_index]] <- as.data.frame(degree(pre_igraph, mode="all"))
  stat$degree[[post_index]] <- as.data.frame(degree(post_igraph, mode="all"))
  #mean degree
  stat$degree_mean[[pre_index]] <- as.numeric(mean(degree(pre_igraph)))
  stat$degree_mean[[post_index]] <- as.numeric(mean(degree(post_igraph)))
  #degree distribution
  stat$degree_dist[[pre_index]] <- as.data.frame(degree_distribution(pre_igraph))
  stat$degree_dist[[post_index]] <- as.data.frame(degree_distribution(post_igraph))
  #transitivity
  stat$transitivity[[pre_index]] <- as.data.frame(transitivity(pre_igraph, type = 'local'))
  stat$transitivity[[post_index]] <- as.data.frame(transitivity(post_igraph, type = 'local'))
  #trans_mean
  stat$trans_mean[[pre_index]] <- as.numeric(mean(stat$transitivity[[pre_index]][[1]]))
  stat$trans_mean[[post_index]] <- as.numeric(mean(stat$transitivity[[post_index]][[1]]))

  #betweenness
  stat$between[[pre_index]] <- as.data.frame(betweenness(pre_igraph))
  stat$between[[post_index]] <- as.data.frame(betweenness(post_igraph))
    #between_mean
  stat$between_mean[[pre_index]] <- as.numeric(mean(stat$between[[pre_index]][[1]]))
  stat$between_mean[[post_index]] <- as.numeric(mean(stat$between[[post_index]][[1]]))

  #eigen centrality
  stat$eigen_cen[[pre_index]] <- as.data.frame(eigen_centrality(pre_igraph)$vector)
  stat$eigen_cen[[post_index]] <- as.data.frame(eigen_centrality(post_igraph)$vector)
  #eigen_cen_mean
  stat$eigen_cen_mean[[pre_index]] <- as.numeric(mean(stat$eigen_cen[[pre_index]][[1]]))
  stat$eigen_cen_mean[[post_index]] <- as.numeric(mean(stat$eigen_cen[[post_index]][[1]]))

}

post_index <- which(stat$network=="post")
stat_post <- stat[post_index,]
stat_post <- stat_post %>% 
  mutate(table=as.factor(table))

```

```{r frequentist/bayes}

library(tidyverse)
pacman::p_load(rstanarm,rstan)

# Step 3: Split the data into training and testing sets
set.seed(123)
train_indices <- sample(nrow(stat_post), nrow(stat_post) * 0.7) # 70% for training
train_data <- stat_post[train_indices, ]
test_data <- stat_post[-train_indices, ]

# Step 4: Build the regression model
model1 <- stan_glmer(eigen_cen_mean ~ degree_mean + trans_mean + between_mean  + (1|table), data = train_data)
summary(model1)
#weird stuff
```
#t.test
```{r}
ttest <- tibble(expand.grid(iteration = seq(1,100),
                           table = seq(1,3),
                           degree = NA,
                           transitivity = NA,
                           between = NA,
                           eigen_cen = NA,
                           degree_dis = NA
                           )
                )

#rename 1:3 to long,round, square
for (row in 1:nrow(ttest)){
ttest$table[row] <- if (ttest$table[row] == 1) "long" else if (ttest$table[row] == 2) "round" else "square"
}

ttest <- ttest %>% 
  mutate(table=as.factor(table))

for (row in 1:nrow(ttest)){
  pre_index <- which(stat$iteration == ttest$iteration[row] & stat$table == ttest$table[row] &stat$network=="pre")
  post_index <- which(stat$iteration == ttest$iteration[row] & stat$table == ttest$table[row] & stat$network == "post")
  
  #degree
  degpre <- stat$degree[pre_index][[1]]$`degree(pre_igraph, mode = "all")`
  degpos <- stat$degree[post_index][[1]]$`degree(post_igraph, mode = "all")`
  t <- t.test(degpos,degpre)
   ttest$degree[[row]] <- t$p.value
   
  #degree_distribution
  degpre <- stat$degree_dist[pre_index][[1]]$`degree_distribution(pre_igraph)`
  degpos <- stat$degree_dist[post_index][[1]]$`degree_distribution(post_igraph)`
  t <- t.test(degpos,degpre)
   ttest$degree_dis[[row]] <- t$p.value
   
  #transitivity
  degpre <- stat$transitivity[pre_index][[1]]$`transitivity(pre_igraph, type = "local")`
  degpos <- stat$transitivity[post_index][[1]]$`transitivity(post_igraph, type = "local")`
  t <- t.test(degpos,degpre)
   ttest$transitivity[[row]] <- t$p.value

  #betweenness
  degpre <- stat$between[pre_index][[1]]$`betweenness(pre_igraph)`
  degpos <- stat$between[post_index][[1]]$`betweenness(post_igraph)`
  t <- t.test(degpos,degpre)
   ttest$between[[row]] <- t$p.value
   
  #eigen_centrality
  degpre <- stat$eigen_cen[pre_index][[1]]$`eigen_centrality(pre_igraph)$vector`
  degpos <- stat$eigen_cen[post_index][[1]]$`eigen_centrality(post_igraph)$vector`
  t <- t.test(degpos,degpre)
   ttest$eigen_cen[[row]] <- t$p.value

}
```


```{r long_square}
long_square <-  tibble(expand.grid(iteration = seq(1,100),
                           table = "long_square",
                           degree = NA,
                           transitivity = NA,
                           between = NA,
                           eigen_cen = NA,
                           degree_dis = NA
                           )
                )


for (row in 1:nrow(long_square)){
  long_index <- which(stat$iteration == long_square$iteration[row] & stat$table == "long" & stat$network=="post")
  square_index <- which(stat$iteration == long_square$iteration[row] & stat$table == "square" & stat$network == "post")
  
    #degree
  degpre <- stat$degree[long_index][[1]]$`degree(post_igraph, mode = "all")`
  degpos <- stat$degree[square_index][[1]]$`degree(post_igraph, mode = "all")`
  t <- t.test(degpos,degpre)
   long_square$degree[[row]] <- t$p.value
   
  #degree_distribution
  degpre <- stat$degree_dist[long_index][[1]]$`degree_distribution(post_igraph)`
  degpos <- stat$degree_dist[square_index][[1]]$`degree_distribution(post_igraph)`
  t <- t.test(degpos,degpre)
   long_square$degree_dis[[row]] <- t$p.value
   
  #transitivity
  degpre <- stat$transitivity[long_index][[1]]$`transitivity(post_igraph, type = "local")`
  degpos <- stat$transitivity[square_index][[1]]$`transitivity(post_igraph, type = "local")`
  t <- t.test(degpos,degpre)
   long_square$transitivity[[row]] <- t$p.value

  #betweenness
  degpre <- stat$between[long_index][[1]]$`betweenness(post_igraph)`
  degpos <- stat$between[square_index][[1]]$`betweenness(post_igraph)`
  t <- t.test(degpos,degpre)
   long_square$between[[row]] <- t$p.value
   
  #eigen_centrality
  degpre <- stat$eigen_cen[long_index][[1]]$`eigen_centrality(post_igraph)$vector`
  degpos <- stat$eigen_cen[square_index][[1]]$`eigen_centrality(post_igraph)$vector`
  t <- t.test(degpos,degpre)
   long_square$eigen_cen[[row]] <- t$p.value

}


sum_long_square <- long_square %>% 
  mutate(degree=as.numeric(round(degree,digits=3))) %>% 
  mutate(transitivity=as.numeric(round(transitivity,digits=3))) %>% 
  mutate(between=as.numeric(round(between,digits=3))) %>% 
  mutate(eigen_cen=as.numeric(round(eigen_cen,digits=3))) %>% 
  mutate(degree_dis=as.numeric(round(degree_dis,digits = 3)))


# Function to count occurrences below 0.05
count_below_threshold <- function(column) {
  sum(column < 0.05)
}

# Apply the function to each column and create the table
r <- sum_long_square[1:100,]
r <- apply(r[, cols.num], 2, count_below_threshold)


degree <- c(r[1][[1]])
degree_dis <- c(r[5][[1]])
transitivity <- c(r[2][[1]])
between <- c(r[3][[1]])
eigen_cen <- c(r[4][[1]])

table <- c("long_square")

results_long_square <- tibble(table = table,degree=degree,degree_distribution=degree_dis,transitivity=transitivity,eigen_centrality=eigen_cen,betweenness=between)



```


```{r pre to post network}
ttest <- ttest %>% 
  mutate(table=as.factor(table))

sum_ttest <- ttest %>% 
  mutate(degree=as.numeric(round(degree,digits=3))) %>% 
  mutate(transitivity=as.numeric(round(transitivity,digits=3))) %>% 
  mutate(between=as.numeric(round(between,digits=3))) %>% 
  mutate(eigen_cen=as.numeric(round(eigen_cen,digits=3))) %>% 
  mutate(degree_dis=as.numeric(round(degree_dis,digits = 3)))


# Function to count occurrences below 0.05
count_below_threshold <- function(column) {
  sum(column < 0.05)
}

# Apply the function to each column and create the table
rl <- sum_ttest[1:100,]
rl <- apply(rl[, cols.num], 2, count_below_threshold)

rs <- sum_ttest[201:300,]
rs <- apply(rs[, cols.num], 2, count_below_threshold)

rr <- sum_ttest[101:200,]
rr <- apply(rr[, cols.num], 2, count_below_threshold)

degree <- c(rl[1][[1]],rs[1][[1]],rr[1][[1]])
degree_dis <- c(rl[5][[1]],rs[5][[1]],rr[5][[1]])
transitivity <- c(rl[2][[1]],rs[2][[1]],rr[2][[1]])
between <- c(rl[3][[1]],rs[3][[1]],rr[3][[1]])
eigen_cen <- c(rl[4][[1]],rs[4][[1]],rr[4][[1]])

table <- c("long","square","round")

results <- tibble(table = table,degree=degree,degree_distribution=degree_dis,transitivity=transitivity,eigen_centrality=eigen_cen,betweenness=between)

```


```{r long_round}
long_round <-  tibble(expand.grid(iteration = seq(1,100),
                           table = "long_round",
                           degree = NA,
                           transitivity = NA,
                           between = NA,
                           eigen_cen = NA,
                           degree_dis = NA
                           )
                )


for (row in 1:nrow(long_round)){
  long_index <- which(stat$iteration == long_round$iteration[row] & stat$table == "long" & stat$network=="post")
  square_index <- which(stat$iteration == long_round$iteration[row] & stat$table == "round" & stat$network == "post")
  
    #degree
  degpre <- stat$degree[long_index][[1]]$`degree(post_igraph, mode = "all")`
  degpos <- stat$degree[square_index][[1]]$`degree(post_igraph, mode = "all")`
  t <- t.test(degpos,degpre)
   long_round$degree[[row]] <- t$p.value
   
  #degree_distribution
  degpre <- stat$degree_dist[long_index][[1]]$`degree_distribution(post_igraph)`
  degpos <- stat$degree_dist[square_index][[1]]$`degree_distribution(post_igraph)`
  t <- t.test(degpos,degpre)
   long_round$degree_dis[[row]] <- t$p.value
   
  #transitivity
  degpre <- stat$transitivity[long_index][[1]]$`transitivity(post_igraph, type = "local")`
  degpos <- stat$transitivity[square_index][[1]]$`transitivity(post_igraph, type = "local")`
  t <- t.test(degpos,degpre)
   long_round$transitivity[[row]] <- t$p.value

  #betweenness
  degpre <- stat$between[long_index][[1]]$`betweenness(post_igraph)`
  degpos <- stat$between[square_index][[1]]$`betweenness(post_igraph)`
  t <- t.test(degpos,degpre)
   long_round$between[[row]] <- t$p.value
   
  #eigen_centrality
  degpre <- stat$eigen_cen[long_index][[1]]$`eigen_centrality(post_igraph)$vector`
  degpos <- stat$eigen_cen[square_index][[1]]$`eigen_centrality(post_igraph)$vector`
  t <- t.test(degpos,degpre)
   long_round$eigen_cen[[row]] <- t$p.value

}


sum_long_round <- long_round %>% 
  mutate(degree=as.numeric(round(degree,digits=3))) %>% 
  mutate(transitivity=as.numeric(round(transitivity,digits=3))) %>% 
  mutate(between=as.numeric(round(between,digits=3))) %>% 
  mutate(eigen_cen=as.numeric(round(eigen_cen,digits=3))) %>% 
  mutate(degree_dis=as.numeric(round(degree_dis,digits = 3)))


# Function to count occurrences below 0.05
count_below_threshold <- function(column) {
  sum(column < 0.05)
}

# Apply the function to each column and create the table
r <- sum_long_round[1:100,]
r <- apply(r[, cols.num], 2, count_below_threshold)


degree <- c(r[1][[1]])
degree_dis <- c(r[5][[1]])
transitivity <- c(r[2][[1]])
between <- c(r[3][[1]])
eigen_cen <- c(r[4][[1]])

table <- c("long_round")

results_long_round <- tibble(table = table,degree=degree,degree_distribution=degree_dis,transitivity=transitivity,eigen_centrality=eigen_cen,betweenness=between)



```

```{r square_round}
square_round <-  tibble(expand.grid(iteration = seq(1,100),
                           table = "square_round",
                           degree = NA,
                           transitivity = NA,
                           between = NA,
                           eigen_cen = NA,
                           degree_dis = NA
                           )
                )


for (row in 1:nrow(square_round)){
  long_index <- which(stat$iteration == square_round$iteration[row] & stat$table == "square" & stat$network=="post")
  square_index <- which(stat$iteration == square_round$iteration[row] & stat$table == "round" & stat$network == "post")
  
    #degree
  degpre <- stat$degree[long_index][[1]]$`degree(post_igraph, mode = "all")`
  degpos <- stat$degree[square_index][[1]]$`degree(post_igraph, mode = "all")`
  t <- t.test(degpos,degpre)
   square_round$degree[[row]] <- t$p.value
   
  #degree_distribution
  degpre <- stat$degree_dist[long_index][[1]]$`degree_distribution(post_igraph)`
  degpos <- stat$degree_dist[square_index][[1]]$`degree_distribution(post_igraph)`
  t <- t.test(degpos,degpre)
   square_round$degree_dis[[row]] <- t$p.value
   
  #transitivity
  degpre <- stat$transitivity[long_index][[1]]$`transitivity(post_igraph, type = "local")`
  degpos <- stat$transitivity[square_index][[1]]$`transitivity(post_igraph, type = "local")`
  t <- t.test(degpos,degpre)
   square_round$transitivity[[row]] <- t$p.value

  #betweenness
  degpre <- stat$between[long_index][[1]]$`betweenness(post_igraph)`
  degpos <- stat$between[square_index][[1]]$`betweenness(post_igraph)`
  t <- t.test(degpos,degpre)
   square_round$between[[row]] <- t$p.value
   
  #eigen_centrality
  degpre <- stat$eigen_cen[long_index][[1]]$`eigen_centrality(post_igraph)$vector`
  degpos <- stat$eigen_cen[square_index][[1]]$`eigen_centrality(post_igraph)$vector`
  t <- t.test(degpos,degpre)
   square_round$eigen_cen[[row]] <- t$p.value

}


sum_square_round <- square_round %>% 
  mutate(degree=as.numeric(round(degree,digits=3))) %>% 
  mutate(transitivity=as.numeric(round(transitivity,digits=3))) %>% 
  mutate(between=as.numeric(round(between,digits=3))) %>% 
  mutate(eigen_cen=as.numeric(round(eigen_cen,digits=3))) %>% 
  mutate(degree_dis=as.numeric(round(degree_dis,digits = 3)))


# Function to count occurrences below 0.05
count_below_threshold <- function(column) {
  sum(column < 0.05)
}

# Apply the function to each column and create the table
r <- sum_square_round[1:100,]
r <- apply(r[, cols.num], 2, count_below_threshold)


degree <- c(r[1][[1]])
degree_dis <- c(r[5][[1]])
transitivity <- c(r[2][[1]])
between <- c(r[3][[1]])
eigen_cen <- c(r[4][[1]])

table <- c("square_round")

results_square_round <- tibble(table = table,degree=degree,degree_distribution=degree_dis,transitivity=transitivity,eigen_centrality=eigen_cen,betweenness=between)



```

```{r plot degree_distribution}

degree_disti <- tibble(degree_dist=as.numeric(), table=as.character(), iteration=as.numeric(),net=as.character())
for (row in 1:nrow(stat)){
  if ((row %% 2)==0){
    temp <- tibble(degree_dist = stat$degree_dist[[row]]$`degree_distribution(post_igraph)`,
                   table = stat$table[row],
                   iteration = stat$iteration[row],
                   net=stat$network[row])
} else{
    temp <- tibble(degree_dist = stat$degree_dist[[row]]$`degree_distribution(pre_igraph)`,
                   table = stat$table[row],
                   iteration = stat$iteration[row],
                   net=stat$network[row]) 
}

degree_disti <- rbind(degree_disti,temp)
}
degree_disti <- degree_disti %>% 
  mutate(table=as.factor(table))
library(ggplot2,gridExtra)
dd <- ggplot(degree_disti, aes(x = degree_dist, fill = table)) +                       # Draw overlaying histogram
  geom_histogram(position = "identity", alpha = 0.6, bins = 50)+
  ggtitle("Degree Distributions for table types")+
  xlab("Degree distribution")+
  ylab("Count")+
  theme_minimal()
```

```{r plot degree}

degree <- tibble(degree=as.numeric(), table=as.character(), iteration=as.numeric(),net=as.character())
for (row in 1:nrow(stat)){
  if ((row %% 2)==0){
    temp <- tibble(degree = stat$degree[[row]]$`degree(post_igraph, mode = "all")`,
                   table = stat$table[row],
                   iteration = stat$iteration[row],
                   net = stat$network[row])
} else{
    temp <- tibble(degree = stat$degree[[row]]$`degree(pre_igraph, mode = "all")`,
                   table = stat$table[row],
                   iteration = stat$iteration[row],
                   net = stat$network[row])}

degree <- rbind(degree,temp)
}

degree <- degree %>% 
  mutate(table=as.factor(table))
library(ggplot2,gridExtra)
d <- ggplot(degree, aes(x = degree, fill = table)) +                       # Draw overlaying histogram
  geom_histogram(position = "identity", alpha = 0.8, bins = 50)+
  ggtitle("Degree for table types")+
  xlab("Degree")+
  ylab("Count")+
  theme_minimal()
```

```{r plot transitivity}

trans <- tibble(trans=as.numeric(), table=as.character(), iteration=as.numeric(), net=as.character())
for (row in 1:nrow(stat)){
  if ((row %% 2)==0){
    temp <- tibble(trans = stat$transitivity[[row]]$`transitivity(post_igraph, type = "local")`,
                   table = stat$table[row],
                   iteration = stat$iteration[row],
                   net=stat$network[row])
} else{
    temp <- tibble(trans = stat$transitivity[[row]]$`transitivity(pre_igraph, type = "local")`,
                   table = stat$table[row],
                   iteration = stat$iteration[row],
                   net=stat$network[row])
}

trans <- rbind(trans,temp)
}

trans <- trans %>% 
  mutate(table=as.factor(table))
library(ggplot2,gridExtra)
t <- ggplot(trans, aes(x = trans, fill = table)) +                       # Draw overlaying histogram
  geom_histogram(position = "identity", alpha = 0.8, bins = 50)+
  ggtitle("Transitivity for table types")+
  xlab("Transitivity")+
  ylab("Count")+
  theme_minimal()
```

```{r plot between}

betw <- tibble(betw=as.numeric(), table=as.character(), iteration=as.numeric(),net=as.character())
for (row in 1:nrow(stat)){
  if ((row %% 2)==0){
    temp <- tibble(betw = stat$between[[row]]$`betweenness(post_igraph)`,
                   table = stat$table[row],
                   iteration = stat$iteration[row],
                   net= stat$network[row])
} else{
    temp <- tibble(betw = stat$between[[row]]$`betweenness(pre_igraph)`,
                   table = stat$table[row],
                   iteration = stat$iteration[row],
                   net= stat$network[row])
}

betw <- rbind(betw,temp)
}

betw <- betw %>% 
  mutate(table=as.factor(table))
library(ggplot2,gridExtra)
b <- ggplot(betw, aes(x = betw, fill = table)) +                       # Draw overlaying histogram
  geom_histogram(position = "identity", alpha = 0.8, bins = 50)+
  ggtitle("Betweenness for table types")+
  xlab("Betweenness")+
  ylab("Count")+
  theme_minimal()
```

```{r plot eigen}

eigen <- tibble(eigen=as.numeric(), table=as.character(), iteration=as.numeric(),net=as.character())
for (row in 1:nrow(stat)){
  if ((row %% 2)==0){
    temp <- tibble(eigen = stat$eigen_cen[[row]]$`eigen_centrality(post_igraph)$vector`,
                   table = stat$table[row],
                   iteration = stat$iteration[row],
                   net=stat$network[row])
} else{
    temp <- tibble(eigen = stat$eigen_cen[[row]]$`eigen_centrality(pre_igraph)$vector`,
                   table = stat$table[row],
                   iteration = stat$iteration[row],
                   net=stat$network[row])
}

eigen <- rbind(eigen,temp)
}

eigen <- eigen %>% 
  mutate(table=as.factor(table))
library(ggplot2,gridExtra)
e <- ggplot(eigen, aes(x = eigen, fill = table)) +                       # Draw overlaying histogram
  geom_histogram(position = "identity", alpha = 0.8, bins = 50)+
  ggtitle("Eigen Centrality for table types")+
  xlab("Eigent Centrality")+
  ylab("Count")+
  theme_minimal()
```

```{r arrange plots}
gridExtra::grid.arrange(d,dd,t,b,e, top="Network Measures",ncol=3)
```
```{r plot pre/post}
pre_post <-  merge(eigen, degree, by = c("table", "iteration","net"), all = TRUE)
pre_post <-  merge(pre_post, degree_disti, by = c("table", "iteration","net"), all = TRUE)
pre_post <-  merge(pre_post, trans, by = c("table", "iteration","net"), all = TRUE)
pre_post <-  merge(pre_post, betw, by = c("table", "iteration","net"), all = TRUE)

eigen <- eigen %>% 
  mutate(table=as.factor(table))
library(ggplot2,gridExtra)
e <- ggplot(eigen, aes(x = eigen, fill = table)) +                       # Draw overlaying histogram
  geom_histogram(position = "identity", alpha = 0.8, bins = 50)+
  ggtitle("Eigen Centrality for table types")+
  xlab("Eigent Centrality")+
  ylab("Count")+
  theme_minimal()
eigen <- eigen %>% 
  mutate(table=as.factor(table))
library(ggplot2,gridExtra)
e <- ggplot(eigen, aes(x = eigen, fill = table)) +                       # Draw overlaying histogram
  geom_histogram(position = "identity", alpha = 0.8, bins = 50)+
  ggtitle("Eigen Centrality for table types")+
  xlab("Eigent Centrality")+
  ylab("Count")+
  theme_minimal()
eigen <- eigen %>% 
  mutate(table=as.factor(table))
library(ggplot2,gridExtra)
e <- ggplot(eigen, aes(x = eigen, fill = table)) +                       # Draw overlaying histogram
  geom_histogram(position = "identity", alpha = 0.8, bins = 50)+
  ggtitle("Eigen Centrality for table types")+
  xlab("Eigent Centrality")+
  ylab("Count")+
  theme_minimal()


```

#Bayes on pre/post
```{r}
library(tidyverse)
pacman::p_load(rstanarm,rstan)
```


```{r}
options(mc.cores = parallel::detectCores())

# Step 4: Build the regression model
e <- rstanarm::stan_glm(eigen ~ table *net, data = eigen)
summary(e)

b <- rstanarm::stan_glm(betw ~ table *net, data = betw)
summary(b)

t <- stan_glm(trans ~ table * net, data = trans)
summary(t)

d <- stan_glm(degree ~ table*net, data = degree)
summary(d)

dd <- stan_glm(degree_dist ~ table*net, data = degree_disti)
summary(dd)


```

## plot
```{r}
colours = c("Pre" = "grey", "Post" = "#E69F00")
```


```{r plot degree_distribution}
degree_disti$table_pre_post <- paste(degree_disti$table, degree_disti$net, sep=':') 
degree_disti <- degree_disti %>% 
  mutate(net=as.factor(net)) %>% 
  mutate(table_pre_post=as.factor(table_pre_post))
degree_disti <- degree_disti %>% 
  mutate(net=str_to_title(net)) %>% 
  mutate(table=str_to_title(table))
library(ggplot2,gridExtra)
 ggplot() +        
    geom_histogram(aes(x = degree_dist, fill = net), data = degree_disti,
                 position = "identity", alpha = 0.6, bins = 50)+

  ggtitle("Degree Distributions")+
  xlab("Degree distribution")+
    facet_wrap(~table)+
  ylab("Count")+
     scale_fill_manual(values = colours)+
  theme_minimal()+theme(legend.position = "none")+
    theme(plot.title = element_text(hjust = 0.5))+
   theme(axis.text.x = element_text(hjust = 1, vjust = 0.5))+
   theme(text = element_text(size = 20))
```

```{r plot degree}
degree$table_pre_post <- paste(degree$table, degree$net, sep=':') 
degree <- degree %>% 
  mutate(Net=as.factor(str_to_title(net))) %>% 
  mutate(table_pre_post=as.factor(table_pre_post)) %>% 
  mutate(table=str_to_title(table))
  
ggplot(degree, aes(x = degree, fill = Net)) +     
  geom_histogram(position = "identity", alpha = 0.8, bins = 50)+
  ggtitle("Degree")+
    facet_wrap(~table)+
  xlab("Degree")+
  ylab("Count")+
  theme_minimal()+
       scale_fill_manual(values = colours)+
    theme(plot.title = element_text(hjust = 0.5))+
   theme(axis.text.x = element_text(hjust = 1, vjust = 0.5))+
    theme(legend.position = "none")+
     theme(text = element_text(size = 20))

```

```{r plot transitivity}
trans$table_pre_post <- paste(trans$table, trans$net, sep=':') 
trans <- trans %>% 
  mutate(Net=as.factor(str_to_title(net))) %>% 
  mutate(table_pre_post=as.factor(table_pre_post)) %>% 
  mutate(table=str_to_title(table))


 ggplot(trans, aes(x = trans, fill = Net)) +                
  geom_histogram(position = "identity", alpha = 0.8, bins = 50)+
  ggtitle("Transitivity")+
  xlab("Transitivity")+
    facet_wrap(~table)+
  ylab("Count")+
  theme_minimal()+
          scale_fill_manual(values = colours)+
    theme(plot.title = element_text(hjust = 0.5))+
   theme(axis.text.x = element_text(hjust = 1, vjust = 0.5))+
    theme(legend.position = "none")+
     theme(text = element_text(size = 20))

```

```{r plot between}
betw$table_pre_post <- paste(betw$table, betw$net, sep=':') 
betw <- betw %>% 
  mutate(Net=as.factor(str_to_title(net))) %>% 
  mutate(table_pre_post=as.factor(table_pre_post)) %>% 
  mutate(table=str_to_title(table))

ggplot(betw, aes(x = betw, fill = Net)) +                       # Draw overlaying histogram
  geom_histogram(position = "identity", alpha = 0.8, bins = 50)+
  ggtitle("Betweenness")+
    facet_wrap(~table)+
  xlab("Betweenness")+
  ylab("Count")+
  theme_minimal()+
       scale_fill_manual(values = colours)+
    theme(plot.title = element_text(hjust = 0.5))+
   theme(axis.text.x = element_text(hjust = 1, vjust = 0.5))+
    theme(legend.position = "none")+
  theme(text=element_text(size=20))

```

```{r plot eigen}
eigen$table_pre_post <- paste(eigen$table, eigen$net, sep=':') 
eigen <- eigen %>% 
  mutate(Net=as.factor(str_to_title(net))) %>% 
  mutate(table_pre_post=as.factor(table_pre_post)) %>% 
  mutate(table=str_to_title(table))



ggplot(eigen, aes(x = eigen, fill = Net)) +                       # Draw overlaying histogram
  geom_histogram(position = "identity", alpha = 0.8, bins = 50)+
  ggtitle("Eigen Centrality")+
  facet_wrap(~table)+
  xlab("Eigent Centrality")+
  ylab("Count")+
  theme_minimal()+
       scale_fill_manual(values = colours)+
    theme(plot.title = element_text(hjust = 0.5))+
   theme(axis.text.x = element_text(hjust = 1, vjust = 0.5))+
  theme(text=element_text(size=20))+
  theme(legend.position = "none")
```



#bayes on post
```{r}
library(tidyverse)
pacman::p_load(rstanarm,rstan)

eb <- eigen[which(eigen$Net=="Post"),]
# Step 3: Split the data into training and testing sets
set.seed(123)
train_indices <- sample(nrow(eb), nrow(eb) * 0.7) # 70% for training
train_data <- eb[train_indices, ]
test_data <- eb[-train_indices, ]

# Step 4: Build the regression model
model1 <- stan_glm(eigen ~ table, data = train_data)
summary(model1)

#predict on test

```

```{r between check}
# Step 3: Split the data into training and testing sets
set.seed(123)
bb <- betw[which(betw$Net=="Post"),]
train_indices <- sample(nrow(bb), nrow(bb) * 0.7) # 70% for training
train_data <- bb[train_indices, ]
test_data <- bb[-train_indices, ]

# Step 4: Build the regression model
model2 <- stan_glm(betw ~ table, data = train_data)
summary(model2)

#predict on test
```

```{r transitivity }
# Step 3: Split the data into training and testing sets
set.seed(123)
tb <- trans[which(trans$Net=="Post"),]
train_indices <- sample(nrow(tb), nrow(tb) * 0.7) # 70% for training
train_data <- tb[train_indices, ]
test_data <- tb[-train_indices, ]

# Step 4: Build the regression model
model31 <- stan_glm(trans ~ table, data = train_data)
summary(model3)
summary(model31)

#predict on test

hist(model31$fitted.values)
y_pointpred_drip <- predict(model31, newdata = test_data)

y_pointpred_drip
hist(y_pointpred_drip)
model31$coefficients[1][[1]] + model31$coefficients[2][[1]]*test_data$trans

```


```{r degree }
# Step 3: Split the data into training and testing sets
set.seed(123)
db <- degree[which(degree$Net=="Post"),]

train_indices <- sample(nrow(db), nrow(db) * 0.7) # 70% for training
train_data <- db[train_indices, ]
test_data <- db[-train_indices, ]

# Step 4: Build the regression model
model4 <- stan_glm(degree ~ table, data = train_data)
summary(model4)

#predict on test

```

```{r degree distribution 0}
# Step 3: Split the data into training and testing sets
set.seed(123)
ddb <- degree_disti[which(degree_disti$net=="Post"),]

train_indices <- sample(nrow(ddb), nrow(ddb) * 0.7) # 70% for training
train_data <- ddb[train_indices, ]
test_data <- ddb[-train_indices, ]

# Step 4: Build the regression model
model5 <- stan_glm(degree_dist ~ table, data = train_data)
summary(model5)

#predict on test

```

## plot
```{r}
colours = c("Long" = "lightblue", "Round" = "#E69F00","Square" = "lightgreen")
```


```{r plot degree_distribution}
ddbp <- ggplot() +        
    geom_histogram(aes(x = degree_dist, fill = table), data = ddb,
                 position = "identity", alpha = 0.6, bins = 50)+

  ggtitle("Degree Distributions")+
  xlab("Degree distribution")+
  ylab("Count")+
     scale_fill_manual(values = colours)+
  theme_minimal()+theme(legend.position = "none")+
    theme(plot.title = element_text(hjust = 0.5))+
   theme(axis.text.x = element_text(hjust = 1, vjust = 0.5))
```

```{r plot degree}
dbp <- ggplot(db, aes(x = degree, fill = table)) +     
  geom_histogram(position = "identity", alpha = 0.8, bins = 50)+
  ggtitle("Degree")+
  xlab("Degree")+
  ylab("Count")+
  theme_minimal()+
       scale_fill_manual(values = colours)+
    theme(plot.title = element_text(hjust = 0.5))+
   theme(axis.text.x = element_text(hjust = 1, vjust = 0.5))+
    theme(legend.position = "none")
```

```{r plot transitivity}
tp <-  ggplot(tb, aes(x = trans, fill = table)) +                
  geom_histogram(position = "identity", alpha = 0.8, bins = 50)+
  ggtitle("Transitivity")+
  xlab("Transitivity")+
  ylab("Count")+
  theme_minimal()+
          scale_fill_manual(values = colours)+
    theme(plot.title = element_text(hjust = 0.5))+
   theme(axis.text.x = element_text(hjust = 1, vjust = 0.5))+
    theme(legend.position = "none")
```

```{r plot between}
bp <- ggplot(bb, aes(x = betw, fill = table)) +           
  geom_histogram(position = "identity", alpha = 0.8, bins = 50)+
  ggtitle("Betweenness")+
  xlab("Betweenness")+
  ylab("Count")+
  theme_minimal()+
       scale_fill_manual(values = colours)+
    theme(plot.title = element_text(hjust = 0.5))+
   theme(axis.text.x = element_text(hjust = 1, vjust = 0.5))+
    theme(legend.position = "none")
```

```{r plot eigen}

ec <- ggplot(eb, aes(x = eigen, fill = table)) +                       # Draw overlaying histogram
  geom_histogram(position = "identity", alpha = 0.8, bins = 50)+
  ggtitle("Eigen Centrality")+
  xlab("Eigent Centrality")+
  ylab("Count")+
  theme_minimal()+
       scale_fill_manual(values = colours)+
    theme(plot.title = element_text(hjust = 0.5))+
   theme(axis.text.x = element_text(hjust = 1, vjust = 0.5))+
  theme(legend.position = "none")
```

```{r}
gridExtra::grid.arrange(ddbp,bp, ec, dbp,tp,ncol=2)
```



# moves
```{r}
#t.test
l_s <-  tibble(expand.grid(iteration = seq(1,100),
                           table = "long_square",
                           moves = NA
                           )
                )


for (row in 1:nrow(l_s)){
  long_index <- which(df_collected$iteration == l_s$iteration[row] & df_collected$table_type == "long")
  square_index <- which(df_collected$iteration == l_s$iteration[row] & df_collected$table_type == "square")
  
    #moves
  degpre <- df_collected$party[long_index][[1]]$moves
  degpos <- df_collected$party[square_index][[1]]$moves
  t <- t.test(degpos,degpre)
   l_s$moves[[row]] <- t$p.value
}

m <- apply(l_s[, "moves"], 2, count_below_threshold)
mov <- c(m[1][[1]])


l_r <-  tibble(expand.grid(iteration = seq(1,100),
                           table = "long_square",
                           moves = NA
                           )
                )


for (row in 1:nrow(l_r)){
  long_index <- which(df_collected$iteration == l_s$iteration[row] & df_collected$table_type == "long")
  square_index <- which(df_collected$iteration == l_s$iteration[row] & df_collected$table_type == "round")
  
    #moves
  degpre <- df_collected$party[long_index][[1]]$moves
  degpos <- df_collected$party[square_index][[1]]$moves
  t <- t.test(degpos,degpre)
   l_r$moves[[row]] <- t$p.value
}

# Apply the function to each column and create the table
mr <- apply(l_r[, "moves"], 2, count_below_threshold)
movr <- c(mr[1][[1]])


s_r <-  tibble(expand.grid(iteration = seq(1,100),
                           table = "square_round",
                           moves = NA
                           )
                )

for (row in 1:nrow(s_r)){
  long_index <- which(df_collected$iteration == l_s$iteration[row] & df_collected$table_type == "square")
  square_index <- which(df_collected$iteration == l_s$iteration[row] & df_collected$table_type == "round")
  
    #moves
  degpre <- df_collected$party[long_index][[1]]$moves
  degpos <- df_collected$party[square_index][[1]]$moves
  t <- t.test(degpos,degpre)
   s_r$moves[[row]] <- t$p.value
}

mrs <- apply(s_r[, "moves"], 2, count_below_threshold)
movsr <- c(mrs[1][[1]])

#collected
tabl <- c("long_square","long_round","square_round")
sig <- c(mov,movr,movsr)
results_move <- tibble(Tables = tabl, `significant difference in moves`=sig)
results_move


#bayes
moves <- tibble(moves=as.numeric(), table=as.character(), iteration=as.numeric())
for (row in 1:nrow(df_collected)){
  temp <- tibble(moves = df_collected$party[row][[1]]$moves,
                   table = df_collected$table_type[row],
                   iteration = df_collected$iteration[row]
                 )
  moves <- rbind(moves,temp)
}

set.seed(123)

train_indices <- sample(nrow(moves), nrow(moves) * 0.7) # 70% for training
train_data <- moves[train_indices, ]
test_data <- moves[-train_indices, ]

# Step 4: Build the regression model
model5 <- stan_glm(moves ~ table, data = train_data)
summary(model5)

#plot
moves <- moves %>% 
  mutate(Table=as.factor(str_to_title(table)))
move <- ggplot(moves, aes(x = moves, fill = Table)) +                       # Draw overlaying histogram
  geom_density(position = "identity", alpha = 0.6)+
   ggtitle("Moves")+
   xlab("Count of moves")+
   ylab("Density")+
  theme_minimal()+
       scale_fill_manual(values = colours)+
    theme(plot.title = element_text(hjust = 0.5))+
   theme(axis.text.x = element_text(hjust = 1, vjust = 0.5))+
  theme(text=element_text(size=20))
move
```


#plot networks
```{r}
#making the networks look the same for easier comparing
E(network_cleaned)$arrow.mode <- 0
V(network_cleaned)$label <- ""

# Community detection
wc1 <- cluster_walktrap(network_cleaned)
# wc1 <- cluster_infomap(as.undirected(network_cleaned))
modularity(wc1)
membership(wc1)

wc2 <- cluster_walktrap(CogSci_2019_n1_igraph)
modularity(wc2)
membership(wc2)


par(mfrow=c(1,2))

plot(wc1, network_cleaned, layout = layout_nicely)
plot(wc2, CogSci_2019_n1_igraph)


# Community detection (by optimizing modularity over partitions):
clp <- cluster_louvain(as.undirected(network_cleaned))
plot(clp, network_cleaned, layout = layout_nicely, edge.arrow.size = 0.2)


clp <- cluster_louvain(as.undirected(CogSci_2019_n1_igraph))
plot(clp, CogSci_2019_n1_igraph, layout = layout_nicely, edge.arrow.size = 0.2)


#clop <- cluster_optimal(CogSci_2019_n1_igraph)
#plot(clop, CogSci_2019_n1_igraph)

#par(mfrow=c(1,1))
```


#STRAND
```{r STRAND}
# library(devtools)
# install_github("ctross/STRAND")
library(STRAND)
```

- Use base priors for the first party out of 300
- run for each party
  - an exposure matrix with the ID's and weights of the maximum outcome (IDxID with 50)
  - 
  
  
outcome = list(inGoing) #matrix of post network
exposte_list = list(exposre) #matrix of max friends weight
dyad = list(friend = pre_network,
satisfaction_distance = satisfaction_dist,
outcome_distance = outcome_dist
)

blocks = df %>%  select(sex, outcome, satisfaction) %>% mutate(sex=as.factor(sex)) %>% as.data.frame()
individual = df %>% select(!c("name", "sex"))


dat = make_strand_data(self_report = outcome,
block_covariets = blocks,
individual_covariaets = individual,
dyadic_covariates = dyad,
exposure = exposure_list,
outcome_mode = "binomial")

f = fit_latent_network_model(
data=dat,
fpr_regression = ~ 1,
rtt_regression = ~ 1,
theta_regression = ~ 1,
focal_regression = ~ 1,
target_regression = ~ 1,
dyad_regression = ~ 1,
mode="mcmc")

r = summarize_strand_results(f)





```{r Matrices}
#try one party
strand_df <- df_collected[1,]

strand_df <- strand_df %>% 
  mutate(table_type=as.factor(table_type))

temp <- strand_df[[3]][[1]]
IDs <- temp$ID

# Create an empty matrix with IDxID dimensions
exposure <- matrix(0, nrow = length(IDs), ncol = length(IDs), dimnames = list(first = IDs, second = IDs))

# Fill the matrix with the value 50
exposure[] <- 50

blocks = strand_df %>% select(table_type) %>% as.data.frame()
individual = temp %>% select(c("ie", "satisfaction_baseline", "weight_time", "weight_interest", "moves", "n_closefriends"))

for (row in 1:nrow(strand_df)){
  #pre
  temp <- strand_df[[4]][row][[1]]
  strand_df[[4]][row][[1]] <- temp %>%
  pivot_wider(names_from = to, values_from = weight, values_fill = 0) %>%
  column_to_rownames(var = "from") %>%
  as.matrix()
  #post
  temp <- strand_df[[5]][row][[1]]
  strand_df[[5]][row][[1]] <- temp %>%
  pivot_wider(names_from = to, values_from = weight, values_fill = 0) %>%
  column_to_rownames(var = "from") %>%
  as.matrix()
  
}

#binary outcome for pre and postnetwork
post <- strand_df[[5]][[1]]
post[post>0] <- 1
 strand_df[[5]][[1]][strand_df[[5]][[1]] > 0] <- 1
 strand_df[[4]][[1]][strand_df[[4]][[1]] > 0] <- 1
# 

#interest matrix

# Convert dataframe into a matrix
i = strand_df[[3]][[1]] %>% select(c("interest1","interest2","interest3"))
interest_matrix <- as.matrix(i)  # Exclude the ID column

# Create an empty matrix with IDxID dimensions
overlap_matrix <- matrix(0, nrow = length(IDs), ncol = length(IDs), dimnames = list(first = IDs, second = IDs))

# Compute the number of overlapping interests
for (i in 1:length(IDs)) {
  for (j in 1:length(IDs)) {
    if (i != j) {
      overlap_count <- sum(interest_matrix[i, ] %in% interest_matrix[j, ])
      overlap_matrix[i, j] <- overlap_count
    }
  }
}
```

```{r}
#make strand dataframe
exposure[exposure>0] <- 1
outcome = list(post,t(post)) #postnetwork
pre <- strand_df[[4]][[1]]
pre[pre>0] <- 1

dyad = list(interests = overlap_matrix, 
            Friends = strand_df[[4]][[1]] #prenetwork
            )


indiv = tibble(IE = individual$ie, 
                    wf = individual$weight_time,  
                    wi = individual$weight_interest,
                    satisfaction = individual$satisfaction_baseline
                     )

exposure_list = list(exposure,exposure)

dat = make_strand_data(self_report = outcome, #why binary?
                       individual_covariates = indiv, 
                       dyadic_covariates = dyad,
                       exposure = exposure_list,
                       outcome_mode = "binomial")


fit = fit_latent_network_model(data=dat,
                                block_regression = ~ 1,
                                focal_regression = ~ IE + wf + wf + satisfaction,
                                target_regression = ~ IE + wf + wf + satisfaction,
                                dyad_regression = ~ interests + Friends,
                                fpr_regression = ~ 1,
                                rtt_regression = ~ 1,
                                theta_regression = ~ 1,
                                mode="mcmc",
                                return_predicted_network = TRUE,
                                stan_mcmc_parameters = list(seed = 1, chains = 1, parallel_chains = 4, refresh = 1, iter_warmup = 100,
                                iter_sampling = 100, max_treedepth = NULL, adapt_delta = NULL)
                                              )
summarize_strand_results(fit)
``