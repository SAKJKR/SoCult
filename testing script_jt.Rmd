---
title: "tryout_abm"
author: "SKK"
date: "2023-05-10"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
pacman::p_load(tidyverse)

```

```{r}
###Define variables from literature###

ie_prob <- c(0.05, 0.15, 0.15, 0.10, 0.10, 0.15, 0.15, 0.10, 0.05) #Introvert/extrovert prob on scale from 1 - 10. From Emma and Mie
int_prob <- c(0.955, 0.955, 0.435, 0.645, 0.625, 0.545, 0.390, 0.325, 0.845, 0.750, 0.320, 0.355, 0.250, 0.215) #Interest probabilities. 14 different interests taken from Statistikbanken.
ven_prob <- c(0.01, 0.02, 0.05, 0.08, 0.12, 0.20, 0.10, 0.04, 0.06, 0.02, 0.30) #Probabilities of having different number of friends. Taken from Vive paper
household_prob <-c(0.3970565,0.333184,0.1130965,0.1074418, 0.03661024,0.008320509, 0.002352696, 0.001937746) # Number of people in your household probability

###Define model variables ###

iterations <- 8 #How many times do we want to run the model?
n_people <- 64 #How many people are at a party?

```


```{r make hosts}
### Define hosts of parties ###

# All host shares at least 1 interest with everyone, and are connected to all guests

max_hosts <- iterations+100 #define the highest host id (+100 to make hosts identifiable)
  
hosts <- tibble(
    ID = 101:max_hosts, #+100 to give the hosts identifyable ID's
     ie = sample(1:9, iterations, replace = TRUE, prob =  ie_prob),    #introvert / extrovert scale from 1-9, from Emma and Mie
     n_household = sample(1:8,iterations, replace =TRUE, prob = household_prob), #Number of people in your household
     n_closefriends = n_people-1, #friends with every one at the party
    #in the tryout markdown the randomization of interest was tested an only a few combination was shown twice, therefore we will not do anything further to randomize the selected interests.
     interest1 = sample(1:14, iterations, replace = TRUE, prob = int_prob),
     interest2 = sample(1:14, iterations, replace = TRUE, prob = int_prob),
     interest3 = sample(1:14, iterations, replace = TRUE, prob = int_prob)
  )
```

```{r test interest overlap}
par(mfrow=c(1,3))
plot(density(hosts$interest1))
plot(density(hosts$interest2))
plot(density(hosts$interest3))
#library(plyr)
dplyr::count_(hosts, vars = c('interest1','interest2','interest3'))
aggregate(ID ~ ., hosts, FUN = length)

dupes <- apply(hosts[,2:4], 1, function(x) any(duplicated(x)))
dupes <- hosts[dupes, ]
dup <- dupes[1,]
stringr::str_count(dupes) #18 true #four characters, =28 procent had an overlap in at least two coloumns
```

```{r setup people for party}
### Choosing who the guests are at all parties

# for (i in iterations){ #just to get a feel of how to set up people function
#  host <- hosts[i,] #choose a host
# }

i = 5

host <- hosts[i,]
host_interest <- c(host$interest1,host$interest2,host$interest3)

#Assigning variables to guests 
guests <- data.frame(ID = 2:n_people-1, #Creating 63 people
                   ie = sample(1:9, n_people-1, replace = TRUE, prob =  ie_prob), #Introvert/extrovert values to people
                   n_household = sample(1:8, n_people-1, replace =TRUE, prob = household_prob), #Amount of people in household
                   n_closefriends = sample(1:10, n_people-1, replace = TRUE, prob = ven_prob[1:10]), #Amount of close friends (everyone has at least one friend (the host))
                   interest1 = sample(host_interest,n_people-1,replace=TRUE), #choose a random interest that fits with the host
                  interest2 = sample(1:14, n_people-1, replace = TRUE, prob = int_prob),
                  interest3 = sample(1:14, n_people-1, replace = TRUE, prob = int_prob)
  )

guests <- as_tibble(rbind(host,guests))
```


```{r setup people for party}
#test if people have overlap in interests within themselves
dupes <- apply(guests[,5:7], 1, function(x) any(duplicated(x)))
stringr::str_count(dupes) #16 true #four characters, =25 procent had an overlap in at least two coloumns

```


```{r friends network}

### Creating a network of the connections pre-party###
pre_network <- expand.grid(from=guests$ID,to=guests$ID)
pre_network$weight <- 0
pre_network <- filter(pre_network, from != to)

guests <- guests %>% 
  mutate(friend_id=NA)

### Assigning friends to everyone
for (i in 1:nrow(guests)) {
  num_friends <- guests$n_closefriends[i]  # Get the number of friends for the current person
  id_pool <- guests$ID[-i]  # Exclude the current person's ID from the pool of potential friends
  
  ids_above_100 <- id_pool[id_pool > 100] #Separate people into host and guests
  ids_below_100 <- id_pool[id_pool <= 100]
  
  # If the current person needs to have more than 1 friend (more than just the host)
  if (num_friends >= 1) {
    # Add all IDs above 100 as friends
    friend_ids_above_100 <- ids_above_100
    remaining_friends <- num_friends - 1
    
    # Randomly select additional friend IDs from below 100
    friend_ids_below_100 <- sample(ids_below_100, size = remaining_friends, replace = FALSE)
    
    # Combine the friend IDs
    friend_ids <- c(friend_ids_above_100, friend_ids_below_100)
  } else {
    # Randomly select friend IDs from above 100
    friend_ids <- sample(ids_above_100, size = num_friends, replace = FALSE)
  }

  # Assign the selected friend IDs to the corresponding row in the dataframe
  guests$friend_id[i] <- paste(friend_ids, collapse = ', ')
}

#Add weight to all the friendships we just created
for (i in 1:nrow(guests)){
  current_id <- guests$ID[i]
  temp <- pre_network %>% filter(from==current_id)
   for (k in strsplit(guests$friend_id[i], ", ")[[1]]){
     temp2 <- temp %>% filter(to==k)
      temp2$weight <- temp2$weight + 16
       temp <- temp %>% filter(to!=k)
      temp <- rbind(temp2, temp)
  }
    pre_network <- pre_network %>% filter(from!=current_id)
    pre_network <- rbind(pre_network, temp)
}


```


```{r plotting networks}
#Plotting Friendship network
pacman::p_load(tidyverse,
               here,
               network,
               igraph,
               ggraph,
               tidygraph,
               patchwork,
               bootnet)
#remove rows that does not have a weight
pre_net <- pre_network[!(pre_network$weight==0),]

pre_net_graph <-
  graph_from_data_frame(d = pre_net,
                        vertices = guests$ID,
                        directed = TRUE)

E(pre_net_graph)$width <- edge_attr(pre_net_graph)$weight/16#this one adjusts the size of arrows 

plot(pre_net_graph,
     layout = layout_on_sphere, # Explore layouts!
     edge.arrow.size = 0.2)

```


--- NÃ¥et hertil ---




```{r creating tables}
#Create 8 tables of 8 people

# Assuming your dataframe is called 'guests' and has a column named 'ID'

# Define the number of tables
num_tables <- 8

# Create a list to store the table dataframes
tables <- vector("list", num_tables)

# Create the table dataframes
for (i in 1:num_tables) {
  table_name <- paste("Table", i, sep = "_")
  tables[[i]] <- data.frame(ID = NULL, Table = NULL, stringsAsFactors = FALSE)
}

#Create a list of people that are not seated yet
no_seat <- guests$ID
no_seat <- no_seat[sample(length(no_seat))]

# Assign guests to tables
table_index <- 1  # Start with the first table
for (i in no_seat) {
  table_name <- paste("Table", table_index, sep = "_")
  temp <- data.frame(ID=i, Table=table_name)
  tables[[table_index]] <- rbind(tables[[table_index]], temp)
  table_index <- table_index + 1
  if (table_index > num_tables) {
    table_index <- 1  # Start from the first table again
  }
}

# Print the table dataframes
for (i in 1:num_tables) {
  table_name <- paste("Table", i, sep = "_")
  print(tables[[i]])
}


```

